<!DOCTYPE html>
<html>
  <head>
    <title>Websocket Network Game Example</title>
    <link href="websocket.css" type="text/css" rel="stylesheet">
    <script src="bundle.js" type="text/javascript"></script>
  </head>
  <body>
    <h1>Websocket Network Game Example</h1>
    <p>
      The following game illustrates the use of 
      <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">websockets</a>.
      Websockets are JavaScript objects that open a two-way
      communication channel between a webpage and a server.
      For this example, we will be hosting our webserver on
      the CIS Linux system using Node.
    </p>
    <h2>Node Server Code</h2>
    <p>
      Node is a server-side implementation of Google's V8 JavaScript
      engine.  As a <i>server</i> implementation, it can do several 
      things that are not allowed in normal JavaScript, most notably
      file I/O.  Conversely, it lacks the DOM, as it is not a browser.
      You can learn more and download Node to install on your own system
      at <a href="https://nodejs.org/en/">https://nodejs.org/</a>.
    </p>
    <p>
      Like all webservers, a Node webserver operates by listening to
      a specific port on its host machine (typically 80 for HTTP, and
      443 for HTTPS).  However, 80 is locked down on CIS linux, so you
      have to use a non-standard port.
    </p>
    <p>
      Once a webserver is running, HTTP requests can be sent to the
      webserver, which immediately responds with whatever you have 
      programmed it to respond with, and the connection is closed.
      While this works well for webpages, and reasonably well for 
      turn-based games, it is not so good for multiplayer persistent
      real-time games.  For these we need a persistant two-way connection,
      like that offered by websockets.
    </p>
    <p>
      We could write our own websocket code - it basically requires 
      upgrading an HTTP request to a websocket connection - but we
      can also utilize libraries within the Node community.  One of
      these is <a href="https://github.com/websockets/ws">ws</a>, 
      and it provides most of the functionality we'd want.  We can 
      install it locally on our linux account with the command 
      <code>npm install --save ws</code>.  Then, in our JavaScript
      code, we can utilize the library with a require call: 
      <code>var WebSocket = require("ws")</code>.
    </p>
    <h2>The Websocket Server</h2>
    <p>
      Our websocket server will run on the CIS Linux server or another
      computer with a static IP address (or we can run it locally, and
      access it as localhost).  We typically will launch the server from
      the command line with node, i.e. <code>node websocket_server.js</code>,
      from the directory that websoket_server.js is located within.
      This launches (and leaves running) the websocket server.  Ctrl + C 
      will halt the server.
    </p>
    <p>
      The command above (<code>node websocket_server.js</code>) executes
      the JavaScript code in the websocket_server.js file.  So in our code,
      we need to start our websocket server by creating it:
      <code><pre>
        var PORT = 8080,
            WebSocketServer = require('ws').Server,
            wss = new WebSocketServer({port: PORT});
      </pre></code>
      Note that we indicate we'll use port 8080, not the standard HTTP port
      80.  This is because the CIS Linux server locks down the commonly used
      ports, so we must use a non-standard one.  Also, you'll likely want to 
      change this value, as the server can only open a port to one program at
      a time, and you don't want to try using the same port your classmates are
      (or sometimes you'll get an error when the port is already in use).
    </p>
    <p>
      The server for our game is authoritative - that is, it is responsible
      for the state of the world, and lets the clients know what is going on.
      So it needs to hold all the state-pertinent information; who the players
      are and where they are on screen, as well as what they look like.  We'll
      keep track of our players with a simple array, and also hold a count of
      players:
      <code><pre>
        // Game State Variables
        var playerCount = 0,
            players = [];
      </pre></code>
    </p>
    <p>
      A player joins our game by opening a websocket connection,
      which triggers a callback on our websocket server.  Let's
      define our connection listener:
      <code><pre>
        wss.on('connection', function(ws) {
      </pre></code>
      The <code>ws</code> argument to our function is the websocket
      channel between this server and the connecting client.  We'll
      use that object to communicate.  Since we have a joining player,
      we'll need to create an object to represent thier state:
      <code><pre>
          // Create a new player
          var player = {
            id: playerCount,
            x: Math.random() * 640,
            y: Math.random() * 640,
            size: 8,
            color: '#' + Math.floor(Math.random()*16777216).toString(16),
            ws: ws
          }
          playerCount++;
      </pre><code>
      Right now, a player is simply a colored dot on the screen,
      so we pick a random spot for them to appear, and a random 
      color.  We also hold onto their websocket connection, as
      we'll need to use that to communicate with the player's 
      client.  Also, note we assign the player an id, which is 
      the current value of playerCount.  Let's make sure our 
      client knows their ID by sending a message to them:
      <code><pre>
          // Send the new player thier ID
          ws.send(JSON.stringify({
            type: 'your-id',
            id: player.id
          }));
      </pre></code>
      A couple of interesting things happen here: we use our
      websocket connection to send a message with its 
      <code>send()</code> method, and the message we send is
      an JavaScript object.  But we use the built-in JSON 
      library to serialize that object as a string with the
      <code>JSON.stringify()</code> method.  This converts
      the JavaScript object to a JSON string (which almost looks
      like JavaScript object, in this case:
      <code>{"type":"your-id","id":0}</code>
      JSON (JavaScript Object Notation) has the benefit of being
      plain-text (so it's human readable) and being <i>almost</i>
      plain JavaScript, so it's easy to understand.  In a more
      complex game, we'd probably want to send binary messages
      instead of text, but it would work very similarly.
    </p>
    <p>
      We also need to let our new player know about the state 
      of the world they are joining - which in our case basically
      means which other players are in the game, where they are,
      and what they look like.  We'll package this information as 
      JSON messages too:
      <code><pre>
          // Notify new player of existing players
          players.forEach( function(existingPlayer){
            ws.send(JSON.stringify({
              type: 'player-joined',
              id: existingPlayer.id,
              x: existingPlayer.x,
              y: existingPlayer.y,
              size: existingPlayer.size,
              color: existingPlayer.color
            }));
          });
      </pre></code>
      Then we need to add our new player to the current game state:
      <code><pre>
          // Add the new player to the player list
          players[player.id] = player;
      </pre></code>
      Note we are using the player's ID as its index in the players
      array; this makes it easy to retrieve the player object later.
      We now need to let all players in the game (including the new 
      player) know about the new player:
      <code><pre>
          // Notify everyone of the new player
          players.forEach( function(existingPlayer) {
            existingPlayer.ws.send(JSON.stringify({
              type:'player-joined', 
              id: player.id,
              x: player.x,
              y: player.y,
              size: player.size,
              color: player.color
            }));
          });
      </pre></code>
      We need to do two more things within our setup code: 
      handle closing events, and receiving messages.  Let's
      start with closing.  We'll want to remove the player 
      from the game, and let everyone know they're gone:
      <code><pre>
        // Handle the websocket closing event
        ws.on('close', function() {
          // Remove the player from our game state
          players.splice(players.indexOf(player), 1);
          
          // Notify remaining players that this player left
          players.forEach( function(remainingPlayer) {
            remainingPlayer.ws.send(JSON.stringify({
              type: 'player-left',
              id: player.id
            }));
          });
        });         
      </pre></code>
      To remove a player, we use the <code>Array.prototype.splice()</code>
      function, which alters the contents of the players array by
      (in this case) removing 1 element starting at the index
      of our player.  Notice also that we use both variables 
      <code>ws</code> and <code>player</code> even though they 
      aren't defined in this function?  They're in the scope of 
      the connection listener, and as this function is defined 
      <i>inside</i> of that scope, it also knows about them - a 
      very useful trick.
    </p>
    <p>
      Message handling works very similarly - we write an event
      listener for the <code>'message'</code> event, which take
      the message as an arguement.  The message has a property,
      <code>body</code> which contains the body of the message,
      in our case, JSON text.  We'll need to deserialize it back
      into a JavaScript object, and then handle its contents:
      <code><pre>
        // Handle websocket messages
        ws.on('message', function(json) {
          var message = JSON.parse(json);
          console.log('received: %s', message.type);

          // Handle messages by type
          switch(message.type) {

            case('move'):
              // Grab the appropriate player
              var player = players[message.id];

              // Move the player
              player.x += message.x;
              player.y += message.y;

              // Notify everyone of the new state
              players.forEach( function (recipient) {
                recipient.ws.send(JSON.stringify({
                  type:'player-moved', 
                  id: player.id,
                  x: player.x,
                  y: player.y
                }));
              });
              break;
          }    
        });
      </pre></code>
      Notice how we use a switch statement to handle different
      types of messages? Actually, we only have one type right 
      now - 'move' - but we can easily add more using this 
      approach, and each can have a very different structure and
      data, provided they all have a 'type' property.
    </p>
    <p>
      That wraps up our connection listener, so we can close its body:
      <code><pre>
      });
      </pre></code>
      And it also wraps up our server code. However, there are a 
      few things we should still think about - especially, can a
      player cheat?  How many different ways exist in this server?
      (Hint: there are at least two).
    </p>
    <h2>The Websocket Client</h2>
    <p>
      The client looks much like the other games we've previously
      written, plus websocket code which closely resembles our server.
      Because we are using browserify, we can still use a Node 
      library with the require call.  We also need to specify our
      port (this should be the same as the one we used for the server),
      <code><pre>
      var WebSocket = require('ws'),
      PORT = 8080;
      </pre></code>
    </p>
    <p>
      Much like before, we'll initialize our game within a 
      <code>window.onload()</code> callback.
      <code><pre>
      // Wait for the window to load completely
      window.onload = function() {
         
        // Players
        var myId,
          players = [];
        
        // Set up the screen canvas
        var screen = document.createElement("canvas");
        screen.width = 640;
        screen.height = 640;
        screenCtx = screen.getContext("2d");
        document.getElementById("game-screen-container").appendChild(screen);
      </pre></code>
    </p>
    <p>
      Then we're ready to set up our websocket client.
      We need to give it a url to our server, including
      our non-standard port, and specify it uses the websocket
      protocol (ws):
      <code><pre>          
        // Set up the websocket client
        ws = new WebSocket('ws://linux.cis.ksu.edu:' + PORT);
      </pre></code>
    </p>
    <p>
      We also need an event handler for websocket messages.
      Just as with the server, these will be JSON strings, so
      we'll need to parse them.  We'll also feed them into
      a switch statement, allowing us to handle multiple message 
      types easily:
      <code><pre>
      // Handler for websocket messages
      ws.onmessage = function(msg) {
        var message = JSON.parse(msg.data);
        
        switch(message.type) {
          case('your-id'):
            myId = message.id;
            break;
            
          case('player-joined'):
            // When a new player joins, add them to the player array
            players[message.id] = {
              x: message.x,
              y: message.y,
              size: message.size,
              color: message.color
            };
            break;
            
          case('player-moved'):
            // When a player has moved, store their new position
            players[message.id].x = message.x;
            players[message.id].y = message.y;
            break;
            
          case('player-left'):
            // When a player leaves, remove them from the player array
            players.splice(players.indexOf(players[message.id]));
            break;
        }
        // re-render the game world after any websocket message,
        // as they each change the state of the world
        render(screenCtx);
      }
      </pre></code>
      Note that we call our <code>render()</code> function after any
      websocket message, as all of them make changes to the game world.
    </p>
    <p>
      Our key handler creates and sends a websocket message when an arrow
      key is pressed.
      <code><pre>
      // Event handler for key events
      window.onkeydown = function(event) {
        switch(event.keyCode) {
          case 37: // left 
            event.preventDefault();
            ws.send(JSON.stringify({
              type: "move", 
              id: myId, 
              x: -1, 
              y: 0
            }));
            break;
            
            ...
        }
      });
      </pre></code>
      This could mean many, many messages being sent to the server.
      Can you think of any alternate ways of handling input to 
      minimize our potential client/server traffic?  
    </p>
    <p>
      Finally, rendering is very straightforward:
      <code><pre>
      // Render 
      function render(ctx) {
        ctx.clearRect(0, 0, 640, 640);
        players.forEach( function(player) {
          ctx.fillStyle = player.color;
          ctx.beginPath();
          ctx.arc(player.x, player.y, player.size, 0, 2*Math.PI);
          ctx.fill();
        });
      }  
      </pre></code>
    </p>
      
    <h2>The Game</h2>
    <p>
      Assuming the game server is running on port 8080, the 
      game will appear below.  Use the arrow keys to move.
    </p>
    <div id="game-screen-container"></div>
  </body>
</html>